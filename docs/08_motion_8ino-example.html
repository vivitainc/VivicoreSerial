<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VivicoreSerial library: 08_motion.ino</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">VivicoreSerial library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">08_motion.ino</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line">#define MIN_LIBRARY_VER_BUILD_NO (0x0012)</div><div class="line">#include &lt;VivicoreSerial.h&gt;</div><div class="line">#include &lt;Wire.h&gt;</div><div class="line">#include &quot;lsm6ds3_reg.h&quot;</div><div class="line">#include &quot;lsm6ds3tr_c_reg.h&quot;</div><div class="line"></div><div class="line">#define MAX_VALUE     (100)</div><div class="line">#define MIN_VALUE     (-1 * MAX_VALUE)</div><div class="line">#define MAX_ACCEL_RAW (2000)                 // Unit: mG force</div><div class="line">#define MAX_ACCEL     (MAX_ACCEL_RAW / 1000) // Unit: G force</div><div class="line">#define MAX_GYRO_RAW  (500000)               // Unit: mdeg/s</div><div class="line">#define MAX_GYRO      (MAX_GYRO_RAW / 1000)  // Unit: deg/s</div><div class="line">#define SLAVE_ADR     (0x6B)</div><div class="line">#define BOOT_TIME     (20) // Unit: ms</div><div class="line"></div><div class="line">const uint16_t USER_FW_VER = 0x000D;</div><div class="line">const uint32_t BRANCH_TYPE = 0x00000008;</div><div class="line"></div><div class="line">const dcInfo_t dcInfo[] = {</div><div class="line">  // {group_no, data_nature, data_type, data_min, data_max}</div><div class="line">  {DcGroup_t::DC_GROUP_1, DcNature_t::DC_NATURE_OUT, DcType_t::DC_TYPE_ANALOG_1BYTE, MIN_VALUE,</div><div class="line">   MAX_VALUE}, // 1: Accel X</div><div class="line">  {DcGroup_t::DC_GROUP_1, DcNature_t::DC_NATURE_OUT, DcType_t::DC_TYPE_ANALOG_1BYTE, MIN_VALUE,</div><div class="line">   MAX_VALUE}, // 2: Accel Y</div><div class="line">  {DcGroup_t::DC_GROUP_1, DcNature_t::DC_NATURE_OUT, DcType_t::DC_TYPE_ANALOG_1BYTE, MIN_VALUE,</div><div class="line">   MAX_VALUE}, // 3: Accel Z</div><div class="line">  {DcGroup_t::DC_GROUP_2, DcNature_t::DC_NATURE_OUT, DcType_t::DC_TYPE_ANALOG_1BYTE, MIN_VALUE, MAX_VALUE}, // 4: Gyro X</div><div class="line">  {DcGroup_t::DC_GROUP_2, DcNature_t::DC_NATURE_OUT, DcType_t::DC_TYPE_ANALOG_1BYTE, MIN_VALUE, MAX_VALUE}, // 5: Gyro Y</div><div class="line">  {DcGroup_t::DC_GROUP_2, DcNature_t::DC_NATURE_OUT, DcType_t::DC_TYPE_ANALOG_1BYTE, MIN_VALUE, MAX_VALUE}, // 6: Gyro Z</div><div class="line">};</div><div class="line"></div><div class="line">/* Initialize mems driver interface */</div><div class="line">typedef float_t (*CONVERT_UNIT)(int16_t raw);</div><div class="line">typedef union {</div><div class="line">  int16_t i16bit[3];</div><div class="line">  uint8_t u8bit[6];</div><div class="line">} axis3bit16_t;</div><div class="line">static uint8_t      whoamI = 0;</div><div class="line">static int32_t      writeReg(void *, uint8_t reg, uint8_t *bufp, uint16_t len);</div><div class="line">static int32_t      readReg(void *, uint8_t reg, uint8_t *bufp, uint16_t len);</div><div class="line">static stmdev_ctx_t dev_ctx = {</div><div class="line">  writeReg, readReg,</div><div class="line">  NULL, // Customizable optional pointer</div><div class="line">};</div><div class="line"></div><div class="line">/* Write generic device register (platform dependent) */</div><div class="line">static int32_t writeReg(void *, uint8_t reg, uint8_t *bufp, uint16_t len) {</div><div class="line">  int32_t ret = 0;</div><div class="line"></div><div class="line">  Wire.beginTransmission(SLAVE_ADR);</div><div class="line">  Wire.write(reg);</div><div class="line">  Wire.write(bufp, len);</div><div class="line">  if (Wire.endTransmission() != 0) {</div><div class="line">    ret = -1;</div><div class="line">  }</div><div class="line"></div><div class="line">  return ret;</div><div class="line">}</div><div class="line"></div><div class="line">/* Read generic device register (platform dependent) */</div><div class="line">static int32_t readReg(void *, uint8_t reg, uint8_t *bufp, uint16_t len) {</div><div class="line">  uint8_t i   = 0;</div><div class="line">  uint8_t c   = 0;</div><div class="line">  int32_t ret = 0;</div><div class="line"></div><div class="line">  Wire.beginTransmission(SLAVE_ADR);</div><div class="line">  Wire.write(reg);</div><div class="line">  if (Wire.endTransmission() != 0) {</div><div class="line">    ret = -1;</div><div class="line">  } else {</div><div class="line">    Wire.requestFrom(SLAVE_ADR, len);</div><div class="line">    while ((Wire.available()) &amp;&amp; (i &lt; len)) {</div><div class="line">      c     = Wire.read();</div><div class="line">      *bufp = c;</div><div class="line">      bufp++;</div><div class="line">      i++;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  return ret;</div><div class="line">}</div><div class="line"></div><div class="line">static uint8_t getAccelCode(const uint8_t maxG) {</div><div class="line">  uint8_t accel = 0;</div><div class="line"></div><div class="line">  if (maxG &lt;= 2) {</div><div class="line">    accel = (whoamI == LSM6DS3_ID) ? (uint8_t)LSM6DS3_2g : (uint8_t)LSM6DS3TR_C_2g;</div><div class="line">  } else if (maxG &lt;= 4) {</div><div class="line">    accel = (whoamI == LSM6DS3_ID) ? (uint8_t)LSM6DS3_4g : (uint8_t)LSM6DS3TR_C_4g;</div><div class="line">  } else if (maxG &lt;= 8) {</div><div class="line">    accel = (whoamI == LSM6DS3_ID) ? (uint8_t)LSM6DS3_8g : (uint8_t)LSM6DS3TR_C_8g;</div><div class="line">  } else {</div><div class="line">    accel = (whoamI == LSM6DS3_ID) ? (uint8_t)LSM6DS3_16g : (uint8_t)LSM6DS3TR_C_16g;</div><div class="line">  }</div><div class="line"></div><div class="line">  DebugPlainPrint0(&quot;Full scale accel:&quot;);</div><div class="line">  DebugHexPrint0(accel);</div><div class="line">  DebugPlainPrintln0();</div><div class="line">  return accel;</div><div class="line">}</div><div class="line"></div><div class="line">static uint8_t getGyroCode(const uint16_t maxDps) {</div><div class="line">  uint8_t gyro = 0;</div><div class="line"></div><div class="line">  if (maxDps &lt;= 125) {</div><div class="line">    gyro = (whoamI == LSM6DS3_ID) ? (uint8_t)LSM6DS3_125dps : (uint8_t)LSM6DS3TR_C_125dps;</div><div class="line">  } else if (maxDps &lt;= 250) {</div><div class="line">    gyro = (whoamI == LSM6DS3_ID) ? (uint8_t)LSM6DS3_250dps : (uint8_t)LSM6DS3TR_C_250dps;</div><div class="line">  } else if (maxDps &lt;= 500) {</div><div class="line">    gyro = (whoamI == LSM6DS3_ID) ? (uint8_t)LSM6DS3_500dps : (uint8_t)LSM6DS3TR_C_500dps;</div><div class="line">  } else if (maxDps &lt;= 1000) {</div><div class="line">    gyro = (whoamI == LSM6DS3_ID) ? (uint8_t)LSM6DS3_1000dps : (uint8_t)LSM6DS3TR_C_1000dps;</div><div class="line">  } else {</div><div class="line">    gyro = (whoamI == LSM6DS3_ID) ? (uint8_t)LSM6DS3_2000dps : (uint8_t)LSM6DS3TR_C_2000dps;</div><div class="line">  }</div><div class="line"></div><div class="line">  DebugPlainPrint0(&quot;Full scale gyro:&quot;);</div><div class="line">  DebugHexPrint0(gyro);</div><div class="line">  DebugPlainPrintln0();</div><div class="line">  return gyro;</div><div class="line">}</div><div class="line"></div><div class="line">static void initSensor(const uint8_t maxG, const uint16_t maxDps) {</div><div class="line">  uint8_t rst = 0;</div><div class="line"></div><div class="line">  /* Wait sensor boot time */</div><div class="line">  delay(BOOT_TIME);</div><div class="line">  /* Check device ID */</div><div class="line">  lsm6ds3_device_id_get(&amp;dev_ctx, &amp;whoamI);</div><div class="line"></div><div class="line">  if (whoamI == LSM6DS3_ID) {</div><div class="line">    const lsm6ds3_xl_fs_t accel = (lsm6ds3_xl_fs_t)getAccelCode(maxG);</div><div class="line">    const lsm6ds3_fs_g_t  gyro  = (lsm6ds3_fs_g_t)getGyroCode(maxDps);</div><div class="line"></div><div class="line">    DebugPlainPrintln0(&quot;LSM6DS3&quot;);</div><div class="line"></div><div class="line">    /* Restore default configuration */</div><div class="line">    lsm6ds3_reset_set(&amp;dev_ctx, PROPERTY_ENABLE);</div><div class="line">    do {</div><div class="line">      lsm6ds3_reset_get(&amp;dev_ctx, &amp;rst);</div><div class="line">    } while (rst);</div><div class="line">    DebugPlainPrintln0(&quot;Reset done&quot;);</div><div class="line"></div><div class="line">    /* Enable Block Data Update */</div><div class="line">    lsm6ds3_block_data_update_set(&amp;dev_ctx, PROPERTY_ENABLE);</div><div class="line">    /* Set full scale */</div><div class="line">    lsm6ds3_xl_full_scale_set(&amp;dev_ctx, accel);</div><div class="line">    lsm6ds3_gy_full_scale_set(&amp;dev_ctx, gyro);</div><div class="line">    /* Set Output Data Rate for Acc and Gyro */</div><div class="line">    lsm6ds3_xl_data_rate_set(&amp;dev_ctx, LSM6DS3_XL_ODR_52Hz);</div><div class="line">    lsm6ds3_gy_data_rate_set(&amp;dev_ctx, LSM6DS3_GY_ODR_52Hz);</div><div class="line">  } else {</div><div class="line">    const lsm6ds3tr_c_fs_xl_t accel = (lsm6ds3tr_c_fs_xl_t)getAccelCode(maxG);</div><div class="line">    const lsm6ds3tr_c_fs_g_t  gyro  = (lsm6ds3tr_c_fs_g_t)getGyroCode(maxDps);</div><div class="line"></div><div class="line">    DebugPlainPrintln0(&quot;LSM6DS3TR_C&quot;);</div><div class="line"></div><div class="line">    /* Restore default configuration */</div><div class="line">    lsm6ds3tr_c_reset_set(&amp;dev_ctx, PROPERTY_ENABLE);</div><div class="line">    do {</div><div class="line">      lsm6ds3tr_c_reset_get(&amp;dev_ctx, &amp;rst);</div><div class="line">    } while (rst);</div><div class="line">    DebugPlainPrintln0(&quot;Reset done&quot;);</div><div class="line"></div><div class="line">    /* Enable Block Data Update */</div><div class="line">    lsm6ds3tr_c_block_data_update_set(&amp;dev_ctx, PROPERTY_ENABLE);</div><div class="line">    /* Set Output Data Rate */</div><div class="line">    lsm6ds3tr_c_xl_data_rate_set(&amp;dev_ctx, LSM6DS3TR_C_XL_ODR_52Hz);</div><div class="line">    lsm6ds3tr_c_gy_data_rate_set(&amp;dev_ctx, LSM6DS3TR_C_GY_ODR_52Hz);</div><div class="line">    /* Set full scale */</div><div class="line">    lsm6ds3tr_c_xl_full_scale_set(&amp;dev_ctx, accel);</div><div class="line">    lsm6ds3tr_c_gy_full_scale_set(&amp;dev_ctx, gyro);</div><div class="line">    /* Configure filtering chain(No aux interface) */</div><div class="line">    /* Accelerometer - analog filter */</div><div class="line">    lsm6ds3tr_c_xl_filter_analog_set(&amp;dev_ctx, LSM6DS3TR_C_XL_ANA_BW_400Hz);</div><div class="line">    /* Accelerometer - LPF1 path ( LPF2 not used )*/</div><div class="line">    lsm6ds3tr_c_xl_lp1_bandwidth_set(&amp;dev_ctx, LSM6DS3TR_C_XL_LP1_ODR_DIV_2);</div><div class="line">    /* Accelerometer - LPF1 + LPF2 path */</div><div class="line">    // lsm6ds3tr_c_xl_lp2_bandwidth_set(&amp;dev_ctx,</div><div class="line">    //                                LSM6DS3TR_C_XL_LOW_NOISE_LP_ODR_DIV_100);</div><div class="line">    /* Accelerometer - High Pass / Slope path */</div><div class="line">    // lsm6ds3tr_c_xl_reference_mode_set(&amp;dev_ctx, PROPERTY_DISABLE);</div><div class="line">    // lsm6ds3tr_c_xl_hp_bandwidth_set(&amp;dev_ctx, LSM6DS3TR_C_XL_HP_ODR_DIV_100);</div><div class="line">    /* Gyroscope - filtering chain */</div><div class="line">    lsm6ds3tr_c_gy_band_pass_set(&amp;dev_ctx, LSM6DS3TR_C_LP2_ONLY);</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line">static bool isSensorDataReady(void) {</div><div class="line">  uint8_t acel_ready = 0;</div><div class="line">  uint8_t gyro_ready = 0;</div><div class="line"></div><div class="line">  /* Read output only if new value is available */</div><div class="line">  if (whoamI == LSM6DS3_ID) {</div><div class="line">    lsm6ds3_xl_flag_data_ready_get(&amp;dev_ctx, &amp;acel_ready);</div><div class="line">    lsm6ds3_gy_flag_data_ready_get(&amp;dev_ctx, &amp;gyro_ready);</div><div class="line">  } else {</div><div class="line">    lsm6ds3tr_c_xl_flag_data_ready_get(&amp;dev_ctx, &amp;acel_ready);</div><div class="line">    lsm6ds3tr_c_gy_flag_data_ready_get(&amp;dev_ctx, &amp;gyro_ready);</div><div class="line">  }</div><div class="line"></div><div class="line">  return ((acel_ready != 0) &amp;&amp; (gyro_ready != 0));</div><div class="line">}</div><div class="line"></div><div class="line">static void getAccelData(const uint8_t maxG, float *accelValues) {</div><div class="line">  static const CONVERT_UNIT converters[] = {</div><div class="line">    lsm6ds3_from_fs2g_to_mg,  // LSM6DS3_2g  = 0</div><div class="line">    lsm6ds3_from_fs16g_to_mg, // LSM6DS3_16g = 1</div><div class="line">    lsm6ds3_from_fs4g_to_mg,  // LSM6DS3_4g  = 2</div><div class="line">    lsm6ds3_from_fs8g_to_mg,  // LSM6DS3_8g  = 3</div><div class="line">  };</div><div class="line">  static const CONVERT_UNIT convertersTrc[] = {</div><div class="line">    lsm6ds3tr_c_from_fs2g_to_mg,  // LSM6DS3TR_C_2g  = 0</div><div class="line">    lsm6ds3tr_c_from_fs16g_to_mg, // LSM6DS3TR_C_16g = 1</div><div class="line">    lsm6ds3tr_c_from_fs4g_to_mg,  // LSM6DS3TR_C_4g  = 2</div><div class="line">    lsm6ds3tr_c_from_fs8g_to_mg,  // LSM6DS3TR_C_8g  = 3</div><div class="line">  };</div><div class="line">  const uint8_t      accel          = getAccelCode(maxG);</div><div class="line">  const CONVERT_UNIT accelConverter = (whoamI == LSM6DS3_ID) ? converters[accel] : convertersTrc[accel];</div><div class="line">  axis3bit16_t       rawAccel       = {};</div><div class="line"></div><div class="line">  /* Read acceleration field data */</div><div class="line">  if (whoamI == LSM6DS3_ID) {</div><div class="line">    lsm6ds3_acceleration_raw_get(&amp;dev_ctx, rawAccel.u8bit);</div><div class="line">  } else {</div><div class="line">    lsm6ds3tr_c_acceleration_raw_get(&amp;dev_ctx, rawAccel.u8bit);</div><div class="line">  }</div><div class="line"></div><div class="line">  /* Convert unit and change the direction of axis for motion branch */</div><div class="line">  accelValues[0] = accelConverter(rawAccel.i16bit[1]);</div><div class="line">  accelValues[1] = accelConverter(rawAccel.i16bit[0]) * (-1.0);</div><div class="line">  accelValues[2] = accelConverter(rawAccel.i16bit[2]) * (-1.0);</div><div class="line">}</div><div class="line"></div><div class="line">static void getGyroData(const uint16_t maxDps, float *gyroValues) {</div><div class="line">  static const CONVERT_UNIT converters[] = {</div><div class="line">    lsm6ds3_from_fs250dps_to_mdps,  // LSM6DS3_250dps  = 0</div><div class="line">    lsm6ds3_from_fs125dps_to_mdps,  // LSM6DS3_125dps  = 1</div><div class="line">    lsm6ds3_from_fs500dps_to_mdps,  // LSM6DS3_500dps  = 2</div><div class="line">    NULL,                           // No dps</div><div class="line">    lsm6ds3_from_fs1000dps_to_mdps, // LSM6DS3_1000dps = 4</div><div class="line">    NULL,                           // No dps</div><div class="line">    lsm6ds3_from_fs2000dps_to_mdps, // LSM6DS3_2000dps = 6</div><div class="line">  };</div><div class="line">  static const CONVERT_UNIT convertersTrc[] = {</div><div class="line">    lsm6ds3tr_c_from_fs250dps_to_mdps,  // LSM6DS3TR_C_250dps  = 0</div><div class="line">    lsm6ds3tr_c_from_fs125dps_to_mdps,  // LSM6DS3TR_C_125dps  = 1</div><div class="line">    lsm6ds3tr_c_from_fs500dps_to_mdps,  // LSM6DS3TR_C_500dps  = 2</div><div class="line">    NULL,                               // No dps</div><div class="line">    lsm6ds3tr_c_from_fs1000dps_to_mdps, // LSM6DS3TR_C_1000dps = 4</div><div class="line">    NULL,                               // No dps</div><div class="line">    lsm6ds3tr_c_from_fs2000dps_to_mdps, // LSM6DS3TR_C_2000dps = 6</div><div class="line">  };</div><div class="line">  const uint8_t      gyro          = getGyroCode(maxDps);</div><div class="line">  const CONVERT_UNIT gyroConverter = (whoamI == LSM6DS3_ID) ? converters[gyro] : convertersTrc[gyro];</div><div class="line">  axis3bit16_t       rawAngular    = {};</div><div class="line"></div><div class="line">  /* Read angular rate field data */</div><div class="line">  if (whoamI == LSM6DS3_ID) {</div><div class="line">    lsm6ds3_angular_rate_raw_get(&amp;dev_ctx, rawAngular.u8bit);</div><div class="line">  } else {</div><div class="line">    lsm6ds3tr_c_angular_rate_raw_get(&amp;dev_ctx, rawAngular.u8bit);</div><div class="line">  }</div><div class="line"></div><div class="line">  /* Convert unit and change the direction of axis for motion branch */</div><div class="line">  gyroValues[0] = gyroConverter(rawAngular.i16bit[1]) * (-1.0);</div><div class="line">  gyroValues[1] = gyroConverter(rawAngular.i16bit[0]);</div><div class="line">  gyroValues[2] = gyroConverter(rawAngular.i16bit[2]);</div><div class="line">}</div><div class="line"></div><div class="line">void setup() {</div><div class="line">  Vivicore.begin(BRANCH_TYPE, USER_FW_VER, dcInfo, countof(dcInfo), MIN_LIBRARY_VER_BUILD_NO);</div><div class="line">  Wire.begin();</div><div class="line">  initSensor(MAX_ACCEL, MAX_GYRO);</div><div class="line">}</div><div class="line"></div><div class="line">void loop() {</div><div class="line">  static const uint8_t DC_NUM               = sizeof(dcInfo) / sizeof(dcInfo[0]);</div><div class="line">  static const float   maxRawValues[DC_NUM] = {</div><div class="line">    MAX_ACCEL_RAW, MAX_ACCEL_RAW, MAX_ACCEL_RAW, MAX_GYRO_RAW, MAX_GYRO_RAW, MAX_GYRO_RAW,</div><div class="line">  };</div><div class="line">  static int8_t prevValues[DC_NUM] = {</div><div class="line">    INT8_MIN, INT8_MIN, INT8_MIN, INT8_MIN, INT8_MIN, INT8_MIN,</div><div class="line">  };</div><div class="line">  float readValues[DC_NUM] = {};</div><div class="line"></div><div class="line">  delay(30);</div><div class="line"></div><div class="line">  /* Read acceleration/angular rate field data */</div><div class="line">  if (!isSensorDataReady()) {</div><div class="line">    return;</div><div class="line">  }</div><div class="line">  getAccelData(MAX_ACCEL, &amp;readValues[0]);</div><div class="line">  getGyroData(MAX_GYRO, &amp;readValues[3]);</div><div class="line"></div><div class="line">  for (uint8_t i = 0; i &lt; DC_NUM; i++) {</div><div class="line">    const float  minRawValue      = -1.0 * maxRawValues[i];</div><div class="line">    const float  maxRawValue      = maxRawValues[i];</div><div class="line">    const long   constrainedValue = (long)(constrain(readValues[i], minRawValue, maxRawValue));</div><div class="line">    const int8_t mappedValue =</div><div class="line">      (int8_t)map(constrainedValue, (long)minRawValue, (long)maxRawValue, MIN_VALUE, MAX_VALUE);</div><div class="line"></div><div class="line">    if (prevValues[i] != mappedValue) {</div><div class="line">      prevValues[i] = mappedValue;</div><div class="line">      Vivicore.write(i + 1, mappedValue);</div><div class="line">    }</div><div class="line"></div><div class="line">    DebugPlainPrint0(readValues[i]);</div><div class="line">    DebugPlainPrint0(&quot;,&quot;);</div><div class="line">    DebugPlainPrint0(constrainedValue);</div><div class="line">    DebugPlainPrint0(&quot;,&quot;);</div><div class="line">    DebugPlainPrint0(mappedValue);</div><div class="line">    DebugPlainPrint0(&quot;,&quot;);</div><div class="line">    DebugHexPrint0((uint8_t)mappedValue);</div><div class="line">    DebugPlainPrint0(&quot; &quot;);</div><div class="line">  }</div><div class="line">  DebugPlainPrintln0();</div><div class="line"></div><div class="line">  Vivicore.flush();</div><div class="line">}</div></div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
